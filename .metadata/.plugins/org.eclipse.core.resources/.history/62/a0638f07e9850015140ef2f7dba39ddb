'''
2
2 4 1
2 1 -2 -1
3 3
-2 1
1 3 1
1 -1 -2
-2 2

1
8 8 3
7 1 6 -1 -9 4 6 5
-3 4
3 6
-6 6
-9 3
-7 3
-9 6
7 3
-6 0
'''

from math import ceil
from _collections import deque



class Node:
    def __init__(self,x,h,v,isOpp):
        self.x = x
        self.y = h
        self.v = v
        self.isOpp = isOpp
        

maxAns = float("inf")
def getResult():
    print
        


def recurse(B, H, E, bal, velo, curr,time):
    global maxAns
    #print B, H, E, bal, velo, curr,time
    if curr == B:
        maxAns = min(maxAns,time)
        return 
    if bal[curr][0] > 0 and velo[bal[curr][1]] < 0:
        for i in xrange(bal[curr][1], H):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] < 0:
                    bal[curr][1] = i
                    diff = i - bal[curr][1]
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1, time + req)
                    bal[curr][1] = i
                    
        for i in xrange(bal[curr][1] - 1, -1, -1):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] < 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1, time + req)
                    bal[curr][1] = i
        
    elif bal[curr][0] < 0 and velo[bal[curr][1]] > 0:
        
        for i in xrange(bal[curr][1], H):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] > 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
        for i in xrange(bal[curr][1] - 1, -1, -1):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] > 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
                    
        
        
    elif bal[curr][0] < 0 and velo[bal[curr][1]] < 0:
        
        for i in xrange(bal[curr][1] + 1, H):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] > 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
        for i in xrange(bal[curr][1] - 1, -1, -1):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] > 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
                    
    elif bal[curr][0] > 0 and velo[bal[curr][1]] > 0:
        for i in xrange(bal[curr][1] + 1, H):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] < 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
        for i in xrange(bal[curr][1] - 1, -1, -1):
            if abs(i - bal[curr][1]) > E:
                break
            else:
                if velo[i] < 0:
                    bal[curr][1] = i
                    diff = abs(i - bal[curr][1])
                    req = int(ceil(abs(bal[curr][0]) / abs(velo[bal[curr][1]])))
                    recurse(B, H, E - diff, bal, velo, curr + 1,time + req)
                    bal[curr][1] = i
        

def calcTime(nodes):
    t = float("-inf")
    for node in nodes:
        time = int(ceil(abs(node.x)/abs(node.v)))
        t = max(t,time)
    return t
    
        

def recurse1(nodes,oppNodes,count,index,E,H,velo):
    if len(oppNodes) > E:
        return False
    elif E == 0:
        if len(oppNodes) > 0:
            return False
        else:
            print "calculateTime"
    else:
        node = nodes[index]
        if node.isOpp:
            if node.x > 0 and node.v > 0:
                for i in xrange(0,H):
                    if i != node.h and velo[i] < 0:
                        diff = abs(i - node.h)
                        oppNodes.remove(node)
                        node.isOpp = False
                        preH = node.h
                        node.h = i
                        recurse1(nodes,oppNodes,count,index + 1,E - diff,H,velo)
                        oppNodes.add(node)
                        node.h = preH
                        node.isOpp = True
            elif node.x < 0 and node.v < 0:
                for i in xrange(0,H):
                    if i != node.h and velo[i] > 0:
                        diff = abs(i - node.h)
                        oppNodes.remove(node)
                        node.isOpp = False
                        preH = node.h
                        node.h = i
                        recurse1(nodes,oppNodes,count,index + 1,E - diff,H,velo)
                        oppNodes.add(node)
                        node.h = preH
                        node.isOpp = True
                
                
                
                        
                        
                    
        #=======================================================================
        # if len(oppNodes):
        #     for oppNode in oppNodes:
        #         for i in xrange(oppNode.h+1,H):
        #             if velo[i] > 0 and node.x < 0:
        #                 temp = oppNode
        #                 oppNodes.remove(oppNode)
        #                 diff = abs(oppNode.h - i)
        #                 recurse1(nodes, oppNodes, count, index, E - diff, H, velo)
        #                 oppNodes.append(temp)
        #             elif velo[i] < 0 and node.x > 0:
        #                 temp = oppNode
        #                 oppNodes.remove(oppNode)
        #                 diff = abs(oppNode.h - i)
        #                 recurse1(nodes, oppNodes, count, index, E - diff, H, velo)
        #                 oppNodes.append(temp)
        #=======================================================================
        
        
        
        
        
        
        
        
    
    

if __name__ == '__main__':
    with open("fourth.txt", "w+") as f:
        for t in xrange(input()):
            B, H, E = map(int, raw_input().split())
            velo = map(int, raw_input().split())
            
            bal = []
            for i in xrange(B):
                bal.append(map(int, raw_input().split()))
                
            
            nodes = list([])   
            count = 0 
            oppNodes = set([])   
            for i in xrange(B):
                isOpp = False
                x,h = map(int,raw_input().split())
                if x < 0 and velo[h] < 0:
                    isOpp = True
                    count += 1
                elif x > 0 and velo[h] > 0:
                    isOpp = True
                    count += 1
                
                node = Node(x,h,velo[h],isOpp)
                if isOpp:
                    nodes.append(node)
                    oppNodes.add(node)
                else:
                    nodes.append(node)
                
                
            #===================================================================
            # count = 0
            # opp = []
            # for i in xrange(B):
            #     if bal[i][0] > 0 and velo[bal[i][1]] > 0:
            #         opp.append(i)
            #         count += 1
            #     elif bal[i][0] < 0 and velo[bal[i][1]] < 0:
            #         opp.append(i)
            #         count += 1
            #===================================================================
            
            if count > E:        
                out = "Case #" + str(t + 1) + ": " + "IMPOSSIBLE" + "\n"
                print out
                f.write(out) 
                continue
            
            
            
            
            
                
            
            
            maxAns = float("inf")    
            recurse(B, H, E, bal, velo, 0, 0)
            result = str(maxAns) if maxAns != float("inf") else "IMPOSSIBLE"
            #print result
            #result = getResult()
            
            out = "Case #" + str(t + 1) + ": " + result + "\n"
            print out
            f.write(out)
