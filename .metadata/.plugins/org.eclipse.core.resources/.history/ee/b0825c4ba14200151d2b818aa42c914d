__author__ = "Ronak Lakhwani"
__copyright__ = "2015 Cisco Systems, Inc."

__about__ = '''
This sample code is meant to track the history of multiple mac addresses using CMX.
To run this code you need to make certain environment changes. The configuration changes are listed below in the configuration
section, which includes information about mse_ip, macs, username, and password.
mse_ip is the IP of the MSE() in the CMX
macs is the list of the mac addresses which are to be tracked
username/password are the credentials to access the apis of the CMX
You do not need to change url_prefix and url_suffix, but it is advised that verify them according to your environment.
If you have any issues running this code
you can submit a bug to the github repository. Be sure to include all the details of your environment.
'''

# General Imports
from datetime import datetime
import random

# Imports for calling the CMX Rest API
import urllib2
from urllib2 import URLError

# Imports for reading the xml response
from bs4 import BeautifulSoup

# Imports for reading the json response
import json


# Imports for plotting the graph
import plotly.plotly as py
import plotly.tools as tls
from plotly.graph_objs import Layout, Marker, Scatter, XAxis, YAxis, Data, Figure

# Imports for certificate fail error
# The below two lines should be uncommented if you are getting [SSL: CERTIFICATE_VERIFY_FAILED] Error. This depends on the browser
# and on the environment depending on whether you have the certificate installed or not.
import ssl
ssl._create_default_https_context = ssl._create_unverified_context

# CONFIGURATION STARTS
# Change it according to your local environment
version = "MSE8.0"
url_prefix = "https://"
mse_ip = "128.107.125.15"
url_suffix = "/api/contextaware/v1/location/history/clients/"
macs = ["3c:a9:f4:33:66:40", "3c:a9:f4:2a:33:64", "14:1a:a3:90:b6:59", "e8:2a:ea:08:32:2a", "90:68:c3:e2:a0:3e"]
username = "learning"
password = "learning"
response_format = "xml"  # Could be xml or json
# CONFIGURATION ENDS 


def get_response(URL, username, password, response_format):
    '''
     Returns the response in the form of dict where keys are isError and others.
     If isError is True then dict contains the other keys such as data which contains the description of the message
     If isError is False then dict contains the other keys such as width,length,data.
    '''
    response_dict = {}
    try :
        p = urllib2.HTTPPasswordMgrWithDefaultRealm()
        p.add_password(None, URL, username, password)
        handler = urllib2.HTTPBasicAuthHandler(p)
        opener = urllib2.build_opener(handler)
        opener.addheaders = [('Accept', 'application/' + response_format)]
        urllib2.install_opener(opener)
        page = urllib2.urlopen(URL).read()
        
        if response_format == "xml" :
            data_dict = getUsefulDataFromXML(page)
        elif response_format == "json":
            data_dict = getUsefulDataFromJson(page)
        data_dict['isError'] = False
        return data_dict
    except URLError, e:
        response_dict['data'] = e
        response_dict['isError'] = True
        return response_dict
    
    

def parse_date(stringDate):
    '''
    Gets the date in the string format 2015-03-17T00:27:33.437+0000 and converts it into 2015-03-17 00:27:33 and then returns the date_object
    '''
    stringDate = stringDate[0:10] + " " + stringDate[11:19]
    date_object = datetime.strptime(stringDate, "%Y-%m-%d %H:%M:%S")
    return date_object

def getUsefulDataFromJson(jsonResponse):
    '''
    Parses the jsonResponse and returns the dict with keys as width, length and the data 
    1. width contains the value of the width
    2. length contains the value of the length
    3. data contains the list of tuples where tuples are in the format (lastlocatedtime,x,y)
    All the above three are returned only when you get location from the jsonResponse otherwise an empty dict is returned
    
    '''
    data = {}
    jsonDict = json.loads(jsonResponse)
    if len(jsonDict['Locations']['entries']) > 0:
        width = jsonDict['Locations']['entries'][0]['MapInfo']['Dimension']['width']
        length = jsonDict['Locations']['entries'][0]['MapInfo']['Dimension']['length']
        
        for wirelessclientlocation in jsonDict['Locations']['entries']:
            mac = wirelessclientlocation["macAddress"]
            if mac in macs:
                x = wirelessclientlocation["MapCoordinate"]["x"]
                y = wirelessclientlocation["MapCoordinate"]["y"]
                lastlocatedtime = parse_date(wirelessclientlocation["Statistics"]["lastLocatedTime"])
                data.setdefault(mac, []).append((lastlocatedtime, x, y))
        return {"width" : width, "length":length, "data":data}
    else :
        return {}

def getUsefulDataFromXML(xml):
    '''
    Parses the xml and returns the dict with keys as width, length and the data 
    1. width contains the value of the width
    2. length contains the value of the length
    3. data is in the form of dictionaries containing key as macaddress(provided above in congiguration section) 
    and the corresponding values as list of tuples where tuples are in the format (lastlocatedtime,x,y)
    All the above three are returned only when you get location from the jsonResponse otherwise an empty dict is returned
    
    '''
    data = {}
    xmlFormat = BeautifulSoup(xml)
    wirelessclientlocations = xmlFormat.find_all("wirelessclientlocation")
    if len(wirelessclientlocations) > 0:
        width = xmlFormat.locations.wirelessclientlocation.mapinfo.dimension['width']
        length = xmlFormat.locations.wirelessclientlocation.mapinfo.dimension['length']
        for wirelessclientlocation in wirelessclientlocations:
            mac = wirelessclientlocation["macaddress"]
            if mac in macs:
                x = wirelessclientlocation.mapcoordinate['x']
                y = wirelessclientlocation.mapcoordinate['y']
                lastlocatedtime = parse_date(wirelessclientlocation.statistics['lastlocatedtime'])
                data.setdefault(mac, []).append((lastlocatedtime, x, y))
        return {"width" : width, "length":length, "data":data}
    else:
        return {}



def plotData(data_dict):
    '''
    Plots the data on the Plotly Framework.
    '''
    py.sign_in('raunaklakhwani', 'n7qx3a5vcn')
    tls.set_credentials_file(username="raunaklakhwani",
                                 api_key="n7qx3a5vcn")
    
    layout = Layout(
                showlegend=True,
                autosize=True,
                height=800,
                width=800,
                title="MAP",
                xaxis=XAxis(
                    zerolinewidth=4,
                    gridwidth=1,
                    showgrid=True,
                    zerolinecolor="#969696",
                    gridcolor="#bdbdbd",
                    linecolor="#636363",
                    mirror=True,
                    zeroline=False,
                    showline=True,
                    linewidth=6,
                    type="linear",
                    range=[0, data_dict["length"]],
                    autorange=False,
                    autotick=False,
                    dtick=15,
                    tickangle=-45,
                    title="X co-ordinate"
                    ),
                yaxis=YAxis(
                    zerolinewidth=4,
                    gridwidth=1,
                    showgrid=True,
                    zerolinecolor="#969696",
                    gridcolor="#bdbdbd",
                    linecolor="#636363",
                    mirror=True,
                    zeroline=False,
                    showline=True,
                    linewidth=6,
                    type="linear",
                    range=[data_dict["width"], 0],
                    autorange=False,
                    autotick=False,
                    dtick=15,
                    tickangle=-45,
                    title="Y co-ordinate"    
                    )
                )
    
    
    macHistoryData = data_dict['data']
    processedData = []
    for mac, pData in macHistoryData.items():
        pData = sorted(pData, key=lambda x:x[0])
        plotData = Scatter(
            x=[x[1] for x in pData],
            y=[y[2] for y in pData],
            mode='lines + text',
            text=range(1, len(pData) + 1),
            name=mac,
            marker=Marker(color=colorGenerator())
        )
        processedData.append(plotData)
    
    
    data = Data(processedData)
    fig = Figure(data=data, layout=layout)
    py.plot(fig, filename='Sample Code For History Of Clients ')
    
    

def colorGenerator():
    '''
    Returns the random color in the form of hexadecimal numbers in the format #XXXXXX
    '''
    def r():
        '''
        Returns the random hexadecimal number between 0-255 in the form of XX
        '''
        hexRandom = hex(random.randint(0, 255))[2:]
        return hexRandom if len(hexRandom) >= 2 else hexRandom + "0"
    return "#" + r() + r() + r()
    
    

if __name__ == '__main__':
    URL = url_prefix + mse_ip + url_suffix
    data_dict = get_response(URL, username, password, response_format)
    if data_dict['isError'] == False:
        if len(data_dict['data']) > 0:
            plotData(data_dict)
        else:
            print 'No clients found'
    else:
        print "Error = ", data_dict['data']
